% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nodeValue.R
\docType{methods}
\name{nodeValue}
\alias{nodeValue}
\alias{nodeValue,ANY-method}
\alias{nodeValue,leafSummarizedExperiment-method}
\alias{nodeValue,treeSummarizedExperiment-method}
\title{Calculate entity values at internal nodes}
\usage{
nodeValue(data, fun = sum, tree, message = FALSE, level = NULL, ...)

\S4method{nodeValue}{ANY}(data, fun = sum, tree, message = FALSE,
  level = NULL)

\S4method{nodeValue}{leafSummarizedExperiment}(data, fun = sum,
  message = FALSE, level = NULL)

\S4method{nodeValue}{treeSummarizedExperiment}(data, fun = sum,
  message = FALSE, level = NULL, col.linkData = "nodeNum")
}
\arguments{
\item{data}{A leafSummarizedExperiment object or a data frame/matrix.}

\item{fun}{A function to create the value of an internal node based on values
at its descendant leaf nodes. The default is sum.}

\item{tree}{An optional argument. Only need if \code{data} is a data frame or
matrix.}

\item{message}{A logical value. The default is TRUE. If TRUE, it will print
out the currenet status of a process.}

\item{level}{A vector of nodes. This indicates the level to which the
aggregation is made. For example, a tree has two main branches (A & B).
Each branch (A or B) has multiple sub-branches. If the aggregation to the
two main branches is desired, we could use \code{ level = c(A, B)},
\code{level = A} or \code{level = B}. In other words, users could specify
the level by provide some branches that covers parts of the tree. The rest
part of the tree is pruned automactially with the minimum number of
branches.}

\item{...}{The additional argument allows only for
\code{treeSummarizedExperiment}.}

\item{col.linkData}{the column names from \code{linkData}.}
}
\value{
If input data is a treeSummarizedExperiment object, a
  treeSummarizedExperiment is returned; otherwise, a matrix is returned
}
\description{
\code{nodeValue} calculates value, e.g., count, for each internal
node based on the values of its descendant leaves. For example, if the
abundance of a cell cluster, which corresponds to an internal node in the
tree, is of interest, we could sum the abundance of all cell types in that
cluster. Each cell type, in this case, corresponds to a leaf node in the
tree. Different calculations, instead of only sum, might be required. This
could be achieved by specifying different functions in the argument
\strong{fun}.
}
\examples{
data("tinyTree")
if (require(ggtree)) {
## The node labels are in orange and the node numbers are in blue
(ggtree(tinyTree,branch.length = 'none')+
    geom_text2(aes(label = label), color = "darkorange",
           hjust = -0.1, vjust = -0.7) +
    geom_text2(aes(label = node), color = "darkblue",
               hjust = -0.5, vjust = 0.7))
set.seed(1)
count <- matrix(rpois(100, 10), nrow =10)
rownames(count) <- tinyTree$tip.label
colnames(count) <- paste(c("C1_", "C2_"),
c(1:5, 1:5), sep = "")

## if the level isn't specified, the aggregation is made at each level
(agg1 <- nodeValue(data = count, tree = tinyTree,
                  fun = sum, level = NULL))

## specify the level that the aggregation should be made to
 # 13 (a branch); 16 (a branch); 9 & 10 (are automatically found and
 #  separate because they are not in a same branch)
(agg2 <- nodeValue(data = count, tree = tinyTree,
                  fun = sum, level = c(13, 16)))

 # 13 (a branch); 15, 10 (are automatically found and
 #  separate because they are not in a same branch)
(agg3 <- nodeValue(data = count, tree = tinyTree,
                  fun = sum, level = c(13)))

# check to see whether the count of an internal node is the sum
# of counts of its descendant leaves.
# here, check the first sample as an example

nod <- transNode(tree = tinyTree, input = rownames(agg1),
                 message = FALSE)
d <- cbind.data.frame(node = nod, count = agg1[, 1])

ggtree(tinyTree) \%<+\% d + geom_text2(aes(label = count))
}

}
\seealso{
\code{\link{treeSummarizedExperiment}} for treeSummarizedExperiment
creation.
}
\author{
Ruizhu Huang
}
