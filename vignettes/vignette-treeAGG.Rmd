---
title: "Tree Aggregation"
author: 
- name: Ruizhu HUANG
  affiliation: 
  - Institute of Molecular Life Sciences, University of Zurich.
  - SIB Swiss Institute of Bioinformatics.
package: treeAGG
output: 
  BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Tree Aggregation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---




```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(ape)
library(treeAGG)
```

# Real data
## Data preparation

To use the **treeAGG** package, two data structures are required: a table of counts of entities (e.g., cell clusters or microbes) across multiple samples, and a hierarchical structure of these entities. Here, we show an example of cytometry data, where the entities are cell clusters and the counts represent the number of cells included in each cluster across a number of biological samples. In this example, we would like to investigate on which hierarchical level the cell clusters are differentially abundant between healthy and cancer subjects.

### Tree 

The tree we use here is the hierarchical structure of cell clusters, obtained by hierarchical clustering of the individual clusters. It's a *hclust* object. To use treeAGG, we need to transform it into a phylo object, using the *as.phylo* function from the **ape** package.

```{r}
data("simTree")
class(simTree)
pTree <- as.phylo(simTree)
class(pTree)
```

## Count table

The count table contains the number of cells in each of the cell clusters across 10 samples, five from healthy subjects and five representing samples from cancer subjects. It's a semi-simulated data set, where one cell population has been spiked in [cite Lukas's paper]. More details are in the data help page.

```{r}
data("simCount")
?simCount
head(simCount)
```

In the count table, each row represents a cell cluster that corresponds to a leaf node in the tree structure, and each column represents a sample. To do tree signal aggregation, we also need counts of the tree internal nodes, representing different resolutions at which data can be interpreted. As *simCount* only provides counts at the leaf level, we generate counts for internal nodes using the code below.

```{r}
# the count of an internal node is the sum of its descendant leaves counts.
# the output table has counts for all nodes (both leaf and internal).
count <- nodeCount(data = simCount, tree = pTree,
                   fun = sum)
dim(count)
```

## Data analysis

We arrange the hypotheses in a tree-like structure and test the hypothesis
$$H_0 : \text{There is not differential abundance}$$ at each node (internal node and leaf node) of the tree.

The Bioconductor package **edgeR** is used here to investigate whether an entity shows differential abundance between conditions, but users are free to perform the testing using any suitable software. The only requirement is that the differential testing outputs a multiple testing-adjusted p-value at each tree node, which can be further used to do the aggregation.
 
```{r}
# rows for internal nodes
isNode <- grepl("Node", rownames(count))
mod <- runEdgeR(data = count, 
                nSam = c(5,5), 
                isTip = !isNode,
                prior.count = 0,
                normalize = TRUE)
head(mod)
```

The output of **edgeR** has multiple columns, one of which is the adjusted p-value (named `FDR`). The adjusted p-value is obtained via the Benjamin-Hochberg method. We could directly use the `mod` table to do the tree aggregation in the next section, or we could extract only the column `FDR`.

## Tree aggregation

To do the tree aggregation, we need a hiearchical tree (`ptree`), and a matrix or data frame with a column of adjusted p-values at each node of the tree (`mod`). `P.lim` is the threshold for the adjusted p-value to reject the null hypothesis. `varSIG` is the name of the column in *data* which contains the adjusted p-values, and `varAGG` is the name of the colum which is used to do the aggregation (here it is also the adjusted p-value).

```{r}
# min - P
loc <- treeAGG(tree = pTree, data = mod,
               P.lim = 0.05, varSIG = "FDR",
               varAGG = "FDR")
loc
```


## Results
### visualisation

The information about the true differential abundance of cell clusters in our semi-simulated data set is stored in the `simTruth` data (More details could be seen via `?simTruth`)

```{r}
data("simTruth")
head(simTruth)
```

We extract the clusters that are truly differentially abundant. `simTruth` only provides the information on the leaf level. If a branch has all its leaves differentially abundant, we would ideally like to aggregate the leaves to the top node of the branch, that is, the node connecting this branch and the other part of the tree.

```{r}
# leaves are differentially abundant (true leaves)
trueTip <- simTruth$cluster[simTruth$true]

# find branch nodes shared by true leaves.
real <- signalNode(node = trueTip, tree = pTree, label = TRUE)
```

Next, we compare the result found with the truth. The branches with blue edges are truly differentially abundant. The results obtained from the minP algorithm are shown as orange points. If an internal node is labelled with an orange point, it means that all its descendant nodes are found to be differentially abundant. In other words, that whole branch is found to have signal. 

```{r}
p <- treePlot(tree = pTree ,  
              branch = real,
              point = loc,
              zoomNode = real,
              layout = "circular")
p
```

To add a legend to the figure, we could use `legend = TRUE` and specify the labels and title for the legend.

```{r}
p <- treePlot(tree = pTree,  
         branch = real,
         point = loc,
         zoomNode = real,
         layout = "circular",
         legend = TRUE, 
         legend.label = list(
           col.branch = "Diff",
           col.other = "Non-diff",
           col.point = "Diff"), 
         legend.title = c(branch = "Truth",
                          point = "Found"))
p
```


### Evaluation

The true positive rate at the leaf level is the ratio of the number of correctly found leaves to the number of truly differentially abundant leaves.

```{r}
# true positive rate at leaf level
(tpr.l <- tpr(tree = pTree, truth = trueTip, 
             found = loc, level = "leaf"))
# true positive rate at leaf level
(tpr.n <- tpr(tree = pTree, truth = trueTip, 
             found = loc, level = "node"))
```

The true positive rate at the node level is the ratio of the number of correctly found nodes to the number of true nodes.

```{r}
# true positive rate at leaf level
(fdr.l <- fdr(tree = pTree, truth = trueTip, 
             found = loc, level = "leaf"))
# true positive rate at leaf level
(fdr.n <- fdr(tree = pTree, truth = trueTip, 
             found = loc, level = "node"))
```

# Simulation

**treeAGG** provides the function `doTable` to simulate different signal patterns.

* scenario one (S1): full signal on two selected branches. Signals within each of the two branches (or clusters) have the same sign and strength.
* scenario two (S2): full signal on two selected branches. Signals within each of the two branches (or clusters) have the same sign but different strength.
* scenario three (S3): one branch have full signal, but the other only have partial signal. Signals within each of the two branches (or clusters) have the same sign and strength.

Full signal means that all leaves on the branch have signal. Partial signal means that only some leaves evenly distributed on that branch have signal.

To simulated a count table using `doTable`, one needs to provide a real hiearchical structure and a real count table of entities. Here, we use a real throat microbiome data set that includes a count table of 856 OTUs (operational taxonomic units) from 60 samples and a phylogenetic tree with 856 leaves and 855 internal nodes. More details about the data could be seen via `?throat.tree` and `?throat.otu.tab`.


```{r}
data("throat.tree")
data("throat.otu.tab")
```


We feed the `doTable` the real data via two arguments `tree` and `data`. `throat.otu.tab` has the samples in the row and entities in the column, so we need to tranpose it before input to `daTable`.

```{r}
set.seed(1)
dat1 <- doTable(tree = throat.tree,
               data = as.matrix(t(throat.otu.tab)),
               ratio = 2)
```

The result, `dat` is a list including a simulated count table (`Count`), a vector of fold change for all entities on tree leaf level (`FC`), and the information of branches where signals are given (`Branch`). 

```{r}
str(dat1)
```

To visualize signal pattern on the tree structure, we could do it as below. 

```{r}
bb1 <- c(dat1$Branch$A, dat1$Branch$B)
treePlot(tree = throat.tree, branch = bb1, 
         col.branch = c("orange", "blue"), 
         zoomNode = bb1, layout = "circular", 
         zoomScale = 50, legend = TRUE, 
         legend.label = list(
           col.branch = c("increase", "decrease")),
         legend.title = c(branch = "Truth")
         )
```

If we want to put signal on larger branch, it could be achieved by changing the value of arguments `minTip.A`, `maxTip.A`, `minTip.B`, `maxTip.B`.

```{r}
dat2 <- doTable(tree = throat.tree,
               data = as.matrix(t(throat.otu.tab)), 
               minTip.A = 20, maxTip.A = 40,
               minTip.B = 20, maxTip.B = 100,
               ratio = 2)
```

```{r}
bb2 <- c(dat2$Branch$A, dat2$Branch$B)
treePlot(tree = throat.tree, branch = bb2, 
         col.branch = c("orange", "blue"), 
         zoomNode = bb2, layout = "circular", 
         zoomScale = 10, legend = TRUE, 
         legend.label = list(
           col.branch = c("increase", "decrease")),
         legend.title = c(branch = "Truth")
         )
```

If one would like to further restrict the abundance level of the selected branches, it could be done by changing the value for the arguments `minPr.A` and `maxPr.A`. These two arguments directly restrict the branch A. One could combine using these two arguments and `ratio` to restrict the branch B.

```{r}
dat3 <- doTable(tree = throat.tree,
               data = as.matrix(t(throat.otu.tab)), 
               minTip.A = 20, maxTip.A = 40,
               minTip.B = 20, maxTip.B = 100, 
               maxPr.A = 0.01,
               ratio = 2)
rbind(dat2$Branch, dat3$Branch)
```


```{r}
bb3<- c(dat3$Branch$A, dat3$Branch$B)
treePlot(tree = throat.tree, branch = bb3, 
         col.branch = c("orange", "blue"), 
         zoomNode = bb3, layout = "circular", 
         zoomScale = 10, legend = TRUE, 
         legend.label = list(
           col.branch = c("increase", "decrease")),
         legend.title = c(branch = "Truth")
         )
```

If one is satisfied with one of the two branches and want to change another branch, then it could be done by using `from.A`.

One could also change different scenarios.... more to be updated.
